{"ast":null,"code":"var Scope = /* @__PURE__ */(Scope2 => (Scope2[Scope2.TYPE = 3] = \"TYPE\", Scope2[Scope2.LEVEL = 12] = \"LEVEL\", Scope2[Scope2.ATTRIBUTE = 13] = \"ATTRIBUTE\", Scope2[Scope2.BLOT = 14] = \"BLOT\", Scope2[Scope2.INLINE = 7] = \"INLINE\", Scope2[Scope2.BLOCK = 11] = \"BLOCK\", Scope2[Scope2.BLOCK_BLOT = 10] = \"BLOCK_BLOT\", Scope2[Scope2.INLINE_BLOT = 6] = \"INLINE_BLOT\", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = \"BLOCK_ATTRIBUTE\", Scope2[Scope2.INLINE_ATTRIBUTE = 5] = \"INLINE_ATTRIBUTE\", Scope2[Scope2.ANY = 15] = \"ANY\", Scope2))(Scope || {});\nclass Attributor {\n  constructor(attrName, keyName) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.attrName = attrName, this.keyName = keyName;\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope = options.scope != null ?\n    // Ignore type bits, force attribute bit\n    options.scope & Scope.LEVEL | attributeBit : Scope.ATTRIBUTE, options.whitelist != null && (this.whitelist = options.whitelist);\n  }\n  static keys(node) {\n    return Array.from(node.attributes).map(item => item.name);\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.setAttribute(this.keyName, value), !0) : !1;\n  }\n  canAdd(_node, value) {\n    return this.whitelist == null ? !0 : typeof value == \"string\" ? this.whitelist.indexOf(value.replace(/[\"']/g, \"\")) > -1 : this.whitelist.indexOf(value) > -1;\n  }\n  remove(node) {\n    node.removeAttribute(this.keyName);\n  }\n  value(node) {\n    const value = node.getAttribute(this.keyName);\n    return this.canAdd(node, value) && value ? value : \"\";\n  }\n}\nclass ParchmentError extends Error {\n  constructor(message) {\n    message = \"[Parchment] \" + message, super(message), this.message = message, this.name = this.constructor.name;\n  }\n}\nconst _Registry = class _Registry {\n  constructor() {\n    this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};\n  }\n  static find(node) {\n    let bubble = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    if (node == null) return null;\n    if (this.blots.has(node)) return this.blots.get(node) || null;\n    if (bubble) {\n      let parentNode = null;\n      try {\n        parentNode = node.parentNode;\n      } catch {\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n  create(scroll, input, value) {\n    const match2 = this.query(input);\n    if (match2 == null) throw new ParchmentError(`Unable to create ${input} blot`);\n    const blotClass = match2,\n      node =\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value),\n      blot = new blotClass(scroll, node, value);\n    return _Registry.blots.set(blot.domNode, blot), blot;\n  }\n  find(node) {\n    let bubble = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    return _Registry.find(node, bubble);\n  }\n  query(query) {\n    let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scope.ANY;\n    let match2;\n    return typeof query == \"string\" ? match2 = this.types[query] || this.attributes[query] : query instanceof Text || query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof query == \"number\" ? query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : query instanceof Element && ((query.getAttribute(\"class\") || \"\").split(/\\s+/).some(name => (match2 = this.classes[name], !!match2)), match2 = match2 || this.tags[query.tagName]), match2 == null ? null : \"scope\" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;\n  }\n  register() {\n    for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {\n      definitions[_key] = arguments[_key];\n    }\n    return definitions.map(definition => {\n      const isBlot = \"blotName\" in definition,\n        isAttr = \"attrName\" in definition;\n      if (!isBlot && !isAttr) throw new ParchmentError(\"Invalid definition\");\n      if (isBlot && definition.blotName === \"abstract\") throw new ParchmentError(\"Cannot register abstract class\");\n      const key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;\n      return this.types[key] = definition, isAttr ? typeof definition.keyName == \"string\" && (this.attributes[definition.keyName] = definition) : isBlot && (definition.className && (this.classes[definition.className] = definition), definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map(tagName => tagName.toUpperCase()) : definition.tagName = definition.tagName.toUpperCase(), (Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName]).forEach(tag => {\n        (this.tags[tag] == null || definition.className == null) && (this.tags[tag] = definition);\n      }))), definition;\n    });\n  }\n};\n_Registry.blots = /* @__PURE__ */new WeakMap();\nlet Registry = _Registry;\nfunction match(node, prefix) {\n  return (node.getAttribute(\"class\") || \"\").split(/\\s+/).filter(name => name.indexOf(`${prefix}-`) === 0);\n}\nclass ClassAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"class\") || \"\").split(/\\s+/).map(name => name.split(\"-\").slice(0, -1).join(\"-\"));\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (this.remove(node), node.classList.add(`${this.keyName}-${value}`), !0) : !1;\n  }\n  remove(node) {\n    match(node, this.keyName).forEach(name => {\n      node.classList.remove(name);\n    }), node.classList.length === 0 && node.removeAttribute(\"class\");\n  }\n  value(node) {\n    const value = (match(node, this.keyName)[0] || \"\").slice(this.keyName.length + 1);\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst ClassAttributor$1 = ClassAttributor;\nfunction camelize(name) {\n  const parts = name.split(\"-\"),\n    rest = parts.slice(1).map(part => part[0].toUpperCase() + part.slice(1)).join(\"\");\n  return parts[0] + rest;\n}\nclass StyleAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"style\") || \"\").split(\";\").map(value => value.split(\":\")[0].trim());\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.style[camelize(this.keyName)] = value, !0) : !1;\n  }\n  remove(node) {\n    node.style[camelize(this.keyName)] = \"\", node.getAttribute(\"style\") || node.removeAttribute(\"style\");\n  }\n  value(node) {\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst StyleAttributor$1 = StyleAttributor;\nclass AttributorStore {\n  constructor(domNode) {\n    this.attributes = {}, this.domNode = domNode, this.build();\n  }\n  attribute(attribute, value) {\n    value ? attribute.add(this.domNode, value) && (attribute.value(this.domNode) != null ? this.attributes[attribute.attrName] = attribute : delete this.attributes[attribute.attrName]) : (attribute.remove(this.domNode), delete this.attributes[attribute.attrName]);\n  }\n  build() {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) return;\n    const attributes = Attributor.keys(this.domNode),\n      classes = ClassAttributor$1.keys(this.domNode),\n      styles = StyleAttributor$1.keys(this.domNode);\n    attributes.concat(classes).concat(styles).forEach(name => {\n      const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n      attr instanceof Attributor && (this.attributes[attr.attrName] = attr);\n    });\n  }\n  copy(target) {\n    Object.keys(this.attributes).forEach(key => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n  move(target) {\n    this.copy(target), Object.keys(this.attributes).forEach(key => {\n      this.attributes[key].remove(this.domNode);\n    }), this.attributes = {};\n  }\n  values() {\n    return Object.keys(this.attributes).reduce((attributes, name) => (attributes[name] = this.attributes[name].value(this.domNode), attributes), {});\n  }\n}\nconst AttributorStore$1 = AttributorStore,\n  _ShadowBlot = class _ShadowBlot {\n    constructor(scroll, domNode) {\n      this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), this.prev = null, this.next = null;\n    }\n    static create(rawValue) {\n      if (this.tagName == null) throw new ParchmentError(\"Blot definition missing tagName\");\n      let node, value;\n      return Array.isArray(this.tagName) ? (typeof rawValue == \"string\" ? (value = rawValue.toUpperCase(), parseInt(value, 10).toString() === value && (value = parseInt(value, 10))) : typeof rawValue == \"number\" && (value = rawValue), typeof value == \"number\" ? node = document.createElement(this.tagName[value - 1]) : value && this.tagName.indexOf(value) > -1 ? node = document.createElement(value) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), this.className && node.classList.add(this.className), node;\n    }\n    // Hack for accessing inherited static methods\n    get statics() {\n      return this.constructor;\n    }\n    attach() {}\n    clone() {\n      const domNode = this.domNode.cloneNode(!1);\n      return this.scroll.create(domNode);\n    }\n    detach() {\n      this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);\n    }\n    deleteAt(index, length) {\n      this.isolate(index, length).remove();\n    }\n    formatAt(index, length, name, value) {\n      const blot = this.isolate(index, length);\n      if (this.scroll.query(name, Scope.BLOT) != null && value) blot.wrap(name, value);else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n        const parent = this.scroll.create(this.statics.scope);\n        blot.wrap(parent), parent.format(name, value);\n      }\n    }\n    insertAt(index, value, def) {\n      const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def),\n        ref = this.split(index);\n      this.parent.insertBefore(blot, ref || void 0);\n    }\n    isolate(index, length) {\n      const target = this.split(index);\n      if (target == null) throw new Error(\"Attempt to isolate at end\");\n      return target.split(length), target;\n    }\n    length() {\n      return 1;\n    }\n    offset() {\n      let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.parent;\n      return this.parent == null || this === root ? 0 : this.parent.children.offset(this) + this.parent.offset(root);\n    }\n    optimize(_context) {\n      this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);\n    }\n    remove() {\n      this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();\n    }\n    replaceWith(name, value) {\n      const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n      return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), this.remove()), replacement;\n    }\n    split(index, _force) {\n      return index === 0 ? this : this.next;\n    }\n    update(_mutations, _context) {}\n    wrap(name, value) {\n      const wrapper = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n      if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), typeof wrapper.appendChild != \"function\") throw new ParchmentError(`Cannot wrap ${name}`);\n      return wrapper.appendChild(this), wrapper;\n    }\n  };\n_ShadowBlot.blotName = \"abstract\";\nlet ShadowBlot = _ShadowBlot;\nconst _LeafBlot = class _LeafBlot extends ShadowBlot {\n  /**\n   * Returns the value represented by domNode if it is this Blot's type\n   * No checking that domNode can represent this Blot type is required so\n   * applications needing it should check externally before calling.\n   */\n  static value(_domNode) {\n    return !0;\n  }\n  /**\n   * Given location represented by node and offset from DOM Selection Range,\n   * return index to that location.\n   */\n  index(node, offset) {\n    return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;\n  }\n  /**\n   * Given index to location within blot, return node and offset representing\n   * that location, consumable by DOM Selection Range\n   */\n  position(index, _inclusive) {\n    let offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);\n    return index > 0 && (offset += 1), [this.parent.domNode, offset];\n  }\n  /**\n   * Return value represented by this blot\n   * Should not change without interaction from API or\n   * user change detectable by update()\n   */\n  value() {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || !0\n    };\n  }\n};\n_LeafBlot.scope = Scope.INLINE_BLOT;\nlet LeafBlot = _LeafBlot;\nconst LeafBlot$1 = LeafBlot;\nclass LinkedList {\n  constructor() {\n    this.head = null, this.tail = null, this.length = 0;\n  }\n  append() {\n    for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      nodes[_key2] = arguments[_key2];\n    }\n    if (this.insertBefore(nodes[0], null), nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n  at(index) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur && index > 0;) index -= 1, cur = next();\n    return cur;\n  }\n  contains(node) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) {\n      if (cur === node) return !0;\n      cur = next();\n    }\n    return !1;\n  }\n  indexOf(node) {\n    const next = this.iterator();\n    let cur = next(),\n      index = 0;\n    for (; cur;) {\n      if (cur === node) return index;\n      index += 1, cur = next();\n    }\n    return -1;\n  }\n  insertBefore(node, refNode) {\n    node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), this.length += 1);\n  }\n  offset(target) {\n    let index = 0,\n      cur = this.head;\n    for (; cur != null;) {\n      if (cur === target) return index;\n      index += cur.length(), cur = cur.next;\n    }\n    return -1;\n  }\n  remove(node) {\n    this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), this.length -= 1);\n  }\n  iterator() {\n    let curNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.head;\n    return () => {\n      const ret = curNode;\n      return curNode != null && (curNode = curNode.next), ret;\n    };\n  }\n  find(index) {\n    let inclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) {\n      const length = cur.length();\n      if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) return [cur, index];\n      index -= length, cur = next();\n    }\n    return [null, 0];\n  }\n  forEach(callback) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) callback(cur), cur = next();\n  }\n  forEachAt(index, length, callback) {\n    if (length <= 0) return;\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    for (; cur && curIndex < index + length;) {\n      const curLength = cur.length();\n      index > curIndex ? callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index)) : callback(cur, 0, Math.min(curLength, index + length - curIndex)), curIndex += curLength, cur = next();\n    }\n  }\n  map(callback) {\n    return this.reduce((memo, cur) => (memo.push(callback(cur)), memo), []);\n  }\n  reduce(callback, memo) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) memo = callback(memo, cur), cur = next();\n    return memo;\n  }\n}\nfunction makeAttachedBlot(node, scroll) {\n  const found = scroll.find(node);\n  if (found) return found;\n  try {\n    return scroll.create(node);\n  } catch {\n    const blot = scroll.create(Scope.INLINE);\n    return Array.from(node.childNodes).forEach(child => {\n      blot.domNode.appendChild(child);\n    }), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), blot;\n  }\n}\nconst _ParentBlot = class _ParentBlot extends ShadowBlot {\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.uiNode = null, this.build();\n  }\n  appendChild(other) {\n    this.insertBefore(other);\n  }\n  attach() {\n    super.attach(), this.children.forEach(child => {\n      child.attach();\n    });\n  }\n  attachUI(node) {\n    this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot.uiClass && this.uiNode.classList.add(_ParentBlot.uiClass), this.uiNode.setAttribute(\"contenteditable\", \"false\"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n  /**\n   * Called during construction, should fill its own children LinkedList.\n   */\n  build() {\n    this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter(node => node !== this.uiNode).reverse().forEach(node => {\n      try {\n        const child = makeAttachedBlot(node, this.scroll);\n        this.insertBefore(child, this.children.head || void 0);\n      } catch (err) {\n        if (err instanceof ParchmentError) return;\n        throw err;\n      }\n    });\n  }\n  deleteAt(index, length) {\n    if (index === 0 && length === this.length()) return this.remove();\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n  descendant(criteria) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const [child, offset] = this.children.find(index);\n    return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [child, offset] : child instanceof _ParentBlot ? child.descendant(criteria, offset) : [null, -1];\n  }\n  descendants(criteria) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_VALUE;\n    let descendants = [],\n      lengthLeft = length;\n    return this.children.forEachAt(index, length, (child, childIndex, childLength) => {\n      (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), child instanceof _ParentBlot && (descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft))), lengthLeft -= childLength;\n    }), descendants;\n  }\n  detach() {\n    this.children.forEach(child => {\n      child.detach();\n    }), super.detach();\n  }\n  enforceAllowedChildren() {\n    let done = !1;\n    this.children.forEach(child => {\n      done || this.statics.allowedChildren.some(def => child instanceof def) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && this.splitAfter(child), child.prev != null && this.splitAfter(child.prev), child.parent.unwrap(), done = !0) : child instanceof _ParentBlot ? child.unwrap() : child.remove());\n    });\n  }\n  formatAt(index, length, name, value) {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n  insertAt(index, value, def) {\n    const [child, offset] = this.children.find(index);\n    if (child) child.insertAt(offset, value, def);else {\n      const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n  insertBefore(childBlot, refBlot) {\n    childBlot.parent != null && childBlot.parent.children.remove(childBlot);\n    let refDomNode = null;\n    this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), childBlot.attach();\n  }\n  length() {\n    return this.children.reduce((memo, child) => memo + child.length(), 0);\n  }\n  moveChildren(targetParent, refNode) {\n    this.children.forEach(child => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n  optimize(context) {\n    if (super.optimize(context), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0) if (this.statics.defaultChild != null) {\n      const child = this.scroll.create(this.statics.defaultChild.blotName);\n      this.appendChild(child);\n    } else this.remove();\n  }\n  path(index) {\n    let inclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    const [child, offset] = this.children.find(index, inclusive),\n      position = [[this, index]];\n    return child instanceof _ParentBlot ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([child, offset]), position);\n  }\n  removeChild(child) {\n    this.children.remove(child);\n  }\n  replaceWith(name, value) {\n    const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n    return replacement instanceof _ParentBlot && this.moveChildren(replacement), super.replaceWith(replacement);\n  }\n  split(index) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    if (!force) {\n      if (index === 0) return this;\n      if (index === this.length()) return this.next;\n    }\n    const after = this.clone();\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      split != null && after.appendChild(split);\n    }), after;\n  }\n  splitAfter(child) {\n    const after = this.clone();\n    for (; child.next != null;) after.appendChild(child.next);\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), after;\n  }\n  unwrap() {\n    this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();\n  }\n  update(mutations, _context) {\n    const addedNodes = [],\n      removedNodes = [];\n    mutations.forEach(mutation => {\n      mutation.target === this.domNode && mutation.type === \"childList\" && (addedNodes.push(...mutation.addedNodes), removedNodes.push(...mutation.removedNodes));\n    }), removedNodes.forEach(node => {\n      if (node.parentNode != null &&\n      // @ts-expect-error Fix me later\n      node.tagName !== \"IFRAME\" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) return;\n      const blot = this.scroll.find(node);\n      blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === this.domNode) && blot.detach();\n    }), addedNodes.filter(node => node.parentNode === this.domNode && node !== this.uiNode).sort((a, b) => a === b ? 0 : a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach(node => {\n      let refBlot = null;\n      node.nextSibling != null && (refBlot = this.scroll.find(node.nextSibling));\n      const blot = makeAttachedBlot(node, this.scroll);\n      (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(this), this.insertBefore(blot, refBlot || void 0));\n    }), this.enforceAllowedChildren();\n  }\n};\n_ParentBlot.uiClass = \"\";\nlet ParentBlot = _ParentBlot;\nconst ParentBlot$1 = ParentBlot;\nfunction isEqual(obj1, obj2) {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) return !1;\n  for (const prop in obj1) if (obj1[prop] !== obj2[prop]) return !1;\n  return !0;\n}\nconst _InlineBlot = class _InlineBlot extends ParentBlot$1 {\n  static create(value) {\n    return super.create(value);\n  }\n  static formats(domNode, scroll) {\n    const match2 = scroll.query(_InlineBlot.blotName);\n    if (!(match2 != null && domNode.tagName === match2.tagName)) {\n      if (typeof this.tagName == \"string\") return !0;\n      if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();\n    }\n  }\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n  }\n  format(name, value) {\n    if (name === this.statics.blotName && !value) this.children.forEach(child => {\n      child instanceof _InlineBlot || (child = child.wrap(_InlineBlot.blotName, !0)), this.attributes.copy(child);\n    }), this.unwrap();else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) return;\n      format instanceof Attributor ? this.attributes.attribute(format, value) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value);\n    }\n  }\n  formats() {\n    const formats = this.attributes.values(),\n      format = this.statics.formats(this.domNode, this.scroll);\n    return format != null && (formats[this.statics.blotName] = format), formats;\n  }\n  formatAt(index, length, name, value) {\n    this.formats()[name] != null || this.scroll.query(name, Scope.ATTRIBUTE) ? this.isolate(index, length).format(name, value) : super.formatAt(index, length, name, value);\n  }\n  optimize(context) {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) return this.unwrap();\n    const next = this.next;\n    next instanceof _InlineBlot && next.prev === this && isEqual(formats, next.formats()) && (next.moveChildren(this), next.remove());\n  }\n  replaceWith(name, value) {\n    const replacement = super.replaceWith(name, value);\n    return this.attributes.copy(replacement), replacement;\n  }\n  update(mutations, context) {\n    super.update(mutations, context), mutations.some(mutation => mutation.target === this.domNode && mutation.type === \"attributes\") && this.attributes.build();\n  }\n  wrap(name, value) {\n    const wrapper = super.wrap(name, value);\n    return wrapper instanceof _InlineBlot && this.attributes.move(wrapper), wrapper;\n  }\n};\n_InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = \"inline\", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = \"SPAN\";\nlet InlineBlot = _InlineBlot;\nconst InlineBlot$1 = InlineBlot,\n  _BlockBlot = class _BlockBlot extends ParentBlot$1 {\n    static create(value) {\n      return super.create(value);\n    }\n    static formats(domNode, scroll) {\n      const match2 = scroll.query(_BlockBlot.blotName);\n      if (!(match2 != null && domNode.tagName === match2.tagName)) {\n        if (typeof this.tagName == \"string\") return !0;\n        if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();\n      }\n    }\n    constructor(scroll, domNode) {\n      super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n    }\n    format(name, value) {\n      const format = this.scroll.query(name, Scope.BLOCK);\n      format != null && (format instanceof Attributor ? this.attributes.attribute(format, value) : name === this.statics.blotName && !value ? this.replaceWith(_BlockBlot.blotName) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value));\n    }\n    formats() {\n      const formats = this.attributes.values(),\n        format = this.statics.formats(this.domNode, this.scroll);\n      return format != null && (formats[this.statics.blotName] = format), formats;\n    }\n    formatAt(index, length, name, value) {\n      this.scroll.query(name, Scope.BLOCK) != null ? this.format(name, value) : super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n      if (def == null || this.scroll.query(value, Scope.INLINE) != null) super.insertAt(index, value, def);else {\n        const after = this.split(index);\n        if (after != null) {\n          const blot = this.scroll.create(value, def);\n          after.parent.insertBefore(blot, after);\n        } else throw new Error(\"Attempt to insertAt after block boundaries\");\n      }\n    }\n    replaceWith(name, value) {\n      const replacement = super.replaceWith(name, value);\n      return this.attributes.copy(replacement), replacement;\n    }\n    update(mutations, context) {\n      super.update(mutations, context), mutations.some(mutation => mutation.target === this.domNode && mutation.type === \"attributes\") && this.attributes.build();\n    }\n  };\n_BlockBlot.blotName = \"block\", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = \"P\", _BlockBlot.allowedChildren = [InlineBlot$1, _BlockBlot, LeafBlot$1];\nlet BlockBlot = _BlockBlot;\nconst BlockBlot$1 = BlockBlot,\n  _ContainerBlot = class _ContainerBlot extends ParentBlot$1 {\n    checkMerge() {\n      return this.next !== null && this.next.statics.blotName === this.statics.blotName;\n    }\n    deleteAt(index, length) {\n      super.deleteAt(index, length), this.enforceAllowedChildren();\n    }\n    formatAt(index, length, name, value) {\n      super.formatAt(index, length, name, value), this.enforceAllowedChildren();\n    }\n    insertAt(index, value, def) {\n      super.insertAt(index, value, def), this.enforceAllowedChildren();\n    }\n    optimize(context) {\n      super.optimize(context), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());\n    }\n  };\n_ContainerBlot.blotName = \"container\", _ContainerBlot.scope = Scope.BLOCK_BLOT;\nlet ContainerBlot = _ContainerBlot;\nconst ContainerBlot$1 = ContainerBlot;\nclass EmbedBlot extends LeafBlot$1 {\n  static formats(_domNode, _scroll) {}\n  format(name, value) {\n    super.formatAt(0, this.length(), name, value);\n  }\n  formatAt(index, length, name, value) {\n    index === 0 && length === this.length() ? this.format(name, value) : super.formatAt(index, length, name, value);\n  }\n  formats() {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\nconst EmbedBlot$1 = EmbedBlot,\n  OBSERVER_CONFIG = {\n    attributes: !0,\n    characterData: !0,\n    characterDataOldValue: !0,\n    childList: !0,\n    subtree: !0\n  },\n  MAX_OPTIMIZE_ITERATIONS = 100,\n  _ScrollBlot = class _ScrollBlot extends ParentBlot$1 {\n    constructor(registry, node) {\n      super(null, node), this.registry = registry, this.scroll = this, this.build(), this.observer = new MutationObserver(mutations => {\n        this.update(mutations);\n      }), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();\n    }\n    create(input, value) {\n      return this.registry.create(this, input, value);\n    }\n    find(node) {\n      let bubble = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      const blot = this.registry.find(node, bubble);\n      return blot ? blot.scroll === this ? blot : bubble ? this.find(blot.scroll.domNode.parentNode, !0) : null : null;\n    }\n    query(query) {\n      let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scope.ANY;\n      return this.registry.query(query, scope);\n    }\n    register() {\n      return this.registry.register(...arguments);\n    }\n    build() {\n      this.scroll != null && super.build();\n    }\n    detach() {\n      super.detach(), this.observer.disconnect();\n    }\n    deleteAt(index, length) {\n      this.update(), index === 0 && length === this.length() ? this.children.forEach(child => {\n        child.remove();\n      }) : super.deleteAt(index, length);\n    }\n    formatAt(index, length, name, value) {\n      this.update(), super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n      this.update(), super.insertAt(index, value, def);\n    }\n    optimize() {\n      var _this = this;\n      let mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      super.optimize(context);\n      const mutationsMap = context.mutationsMap || /* @__PURE__ */new WeakMap();\n      let records = Array.from(this.observer.takeRecords());\n      for (; records.length > 0;) mutations.push(records.pop());\n      const mark = function (blot) {\n          let markParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          blot == null || blot === _this || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), markParent && mark(blot.parent));\n        },\n        optimize = blot => {\n          mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(optimize), mutationsMap.delete(blot.domNode), blot.optimize(context));\n        };\n      let remaining = mutations;\n      for (let i = 0; remaining.length > 0; i += 1) {\n        if (i >= MAX_OPTIMIZE_ITERATIONS) throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n        for (remaining.forEach(mutation => {\n          const blot = this.find(mutation.target, !0);\n          blot != null && (blot.domNode === mutation.target && (mutation.type === \"childList\" ? (mark(this.find(mutation.previousSibling, !1)), Array.from(mutation.addedNodes).forEach(node => {\n            const child = this.find(node, !1);\n            mark(child, !1), child instanceof ParentBlot$1 && child.children.forEach(grandChild => {\n              mark(grandChild, !1);\n            });\n          })) : mutation.type === \"attributes\" && mark(blot.prev)), mark(blot));\n        }), this.children.forEach(optimize), remaining = Array.from(this.observer.takeRecords()), records = remaining.slice(); records.length > 0;) mutations.push(records.pop());\n      }\n    }\n    update(mutations) {\n      let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      mutations = mutations || this.observer.takeRecords();\n      const mutationsMap = /* @__PURE__ */new WeakMap();\n      mutations.map(mutation => {\n        const blot = this.find(mutation.target, !0);\n        return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), null) : (mutationsMap.set(blot.domNode, [mutation]), blot);\n      }).forEach(blot => {\n        blot != null && blot !== this && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);\n      }), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && super.update(mutationsMap.get(this.domNode), context), this.optimize(mutations, context);\n    }\n  };\n_ScrollBlot.blotName = \"scroll\", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = \"DIV\";\nlet ScrollBlot = _ScrollBlot;\nconst ScrollBlot$1 = ScrollBlot,\n  _TextBlot = class _TextBlot extends LeafBlot$1 {\n    static create(value) {\n      return document.createTextNode(value);\n    }\n    static value(domNode) {\n      return domNode.data;\n    }\n    constructor(scroll, node) {\n      super(scroll, node), this.text = this.statics.value(this.domNode);\n    }\n    deleteAt(index, length) {\n      this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n    }\n    index(node, offset) {\n      return this.domNode === node ? offset : -1;\n    }\n    insertAt(index, value, def) {\n      def == null ? (this.text = this.text.slice(0, index) + value + this.text.slice(index), this.domNode.data = this.text) : super.insertAt(index, value, def);\n    }\n    length() {\n      return this.text.length;\n    }\n    optimize(context) {\n      super.optimize(context), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());\n    }\n    position(index) {\n      let _inclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      return [this.domNode, index];\n    }\n    split(index) {\n      let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      if (!force) {\n        if (index === 0) return this;\n        if (index === this.length()) return this.next;\n      }\n      const after = this.scroll.create(this.domNode.splitText(index));\n      return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), after;\n    }\n    update(mutations, _context) {\n      mutations.some(mutation => mutation.type === \"characterData\" && mutation.target === this.domNode) && (this.text = this.statics.value(this.domNode));\n    }\n    value() {\n      return this.text;\n    }\n  };\n_TextBlot.blotName = \"text\", _TextBlot.scope = Scope.INLINE_BLOT;\nlet TextBlot = _TextBlot;\nconst TextBlot$1 = TextBlot;\nexport { Attributor, AttributorStore$1 as AttributorStore, BlockBlot$1 as BlockBlot, ClassAttributor$1 as ClassAttributor, ContainerBlot$1 as ContainerBlot, EmbedBlot$1 as EmbedBlot, InlineBlot$1 as InlineBlot, LeafBlot$1 as LeafBlot, ParentBlot$1 as ParentBlot, Registry, Scope, ScrollBlot$1 as ScrollBlot, StyleAttributor$1 as StyleAttributor, TextBlot$1 as TextBlot };","map":{"version":3,"names":["Scope","Scope2","TYPE","LEVEL","ATTRIBUTE","BLOT","INLINE","BLOCK","BLOCK_BLOT","INLINE_BLOT","BLOCK_ATTRIBUTE","INLINE_ATTRIBUTE","ANY","Attributor","constructor","attrName","keyName","options","arguments","length","undefined","attributeBit","scope","whitelist","keys","node","Array","from","attributes","map","item","name","add","value","canAdd","setAttribute","_node","indexOf","replace","remove","removeAttribute","getAttribute","ParchmentError","Error","message","_Registry","classes","tags","types","find","bubble","blots","has","get","parentNode","create","scroll","input","match2","query","blotClass","Node","nodeType","TEXT_NODE","blot","set","domNode","Text","text","block","inline","Element","split","some","tagName","register","_len","definitions","_key","definition","isBlot","isAttr","blotName","key","className","isArray","toUpperCase","forEach","tag","WeakMap","Registry","match","prefix","filter","ClassAttributor","slice","join","classList","ClassAttributor$1","camelize","parts","rest","part","StyleAttributor","trim","style","StyleAttributor$1","AttributorStore","build","attribute","styles","concat","attr","copy","target","Object","format","move","values","reduce","AttributorStore$1","_ShadowBlot","prev","next","rawValue","parseInt","toString","document","createElement","statics","attach","clone","cloneNode","detach","parent","removeChild","delete","deleteAt","index","isolate","formatAt","wrap","insertAt","def","ref","insertBefore","offset","root","children","optimize","_context","requiredContainer","replaceWith","replacement","_force","update","_mutations","wrapper","appendChild","ShadowBlot","_LeafBlot","_domNode","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","Math","min","position","_inclusive","childNodes","LeafBlot","LeafBlot$1","LinkedList","head","tail","append","_len2","nodes","_key2","at","iterator","cur","contains","refNode","curNode","ret","inclusive","callback","forEachAt","startNode","curIndex","curLength","memo","push","makeAttachedBlot","found","child","replaceChild","_ParentBlot","uiNode","other","attachUI","uiClass","firstChild","reverse","err","childLength","descendant","criteria","descendants","Number","MAX_VALUE","lengthLeft","childIndex","enforceAllowedChildren","done","allowedChildren","splitAfter","unwrap","childBlot","refBlot","refDomNode","nextSibling","moveChildren","targetParent","context","defaultChild","path","force","after","_length","mutations","addedNodes","removedNodes","mutation","type","body","sort","a","b","DOCUMENT_POSITION_FOLLOWING","ParentBlot","ParentBlot$1","isEqual","obj1","obj2","prop","_InlineBlot","formats","toLowerCase","InlineBlot","InlineBlot$1","_BlockBlot","BlockBlot","BlockBlot$1","_ContainerBlot","checkMerge","ContainerBlot","ContainerBlot$1","EmbedBlot","_scroll","EmbedBlot$1","OBSERVER_CONFIG","characterData","characterDataOldValue","childList","subtree","MAX_OPTIMIZE_ITERATIONS","_ScrollBlot","registry","observer","MutationObserver","observe","disconnect","_this","mutationsMap","records","takeRecords","pop","mark","markParent","remaining","i","previousSibling","grandChild","ScrollBlot","ScrollBlot$1","_TextBlot","createTextNode","data","splitText","TextBlot","TextBlot$1"],"sources":["/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/scope.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/attributor/attributor.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/error.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/registry.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/attributor/class.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/attributor/style.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/attributor/store.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/blot/abstract/shadow.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/blot/abstract/leaf.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/collection/linked-list.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/blot/abstract/parent.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/blot/inline.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/blot/block.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/blot/abstract/container.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/blot/embed.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/blot/scroll.ts","/home/vassil/Documents/uni/sem9/gadna_java/my-static-react-app/node_modules/parchment/src/blot/text.ts"],"sourcesContent":["enum Scope {\n  TYPE = (1 << 2) - 1, // 0011 Lower two bits\n  LEVEL = ((1 << 2) - 1) << 2, // 1100 Higher two bits\n\n  ATTRIBUTE = (1 << 0) | LEVEL, // 1101\n  BLOT = (1 << 1) | LEVEL, // 1110\n  INLINE = (1 << 2) | TYPE, // 0111\n  BLOCK = (1 << 3) | TYPE, // 1011\n\n  BLOCK_BLOT = BLOCK & BLOT, // 1010\n  INLINE_BLOT = INLINE & BLOT, // 0110\n  BLOCK_ATTRIBUTE = BLOCK & ATTRIBUTE, // 1001\n  INLINE_ATTRIBUTE = INLINE & ATTRIBUTE, // 0101\n\n  ANY = TYPE | LEVEL,\n}\n\nexport default Scope;\n","import Scope from '../scope.js';\n\nexport interface AttributorOptions {\n  scope?: Scope;\n  whitelist?: string[];\n}\n\nexport default class Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return Array.from(node.attributes).map((item: Attr) => item.name);\n  }\n\n  public scope: Scope;\n  public whitelist: string[] | undefined;\n\n  constructor(\n    public readonly attrName: string,\n    public readonly keyName: string,\n    options: AttributorOptions = {},\n  ) {\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope =\n      options.scope != null\n        ? // Ignore type bits, force attribute bit\n          (options.scope & Scope.LEVEL) | attributeBit\n        : Scope.ATTRIBUTE;\n    if (options.whitelist != null) {\n      this.whitelist = options.whitelist;\n    }\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    node.setAttribute(this.keyName, value);\n    return true;\n  }\n\n  public canAdd(_node: HTMLElement, value: any): boolean {\n    if (this.whitelist == null) {\n      return true;\n    }\n    if (typeof value === 'string') {\n      return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n    } else {\n      return this.whitelist.indexOf(value) > -1;\n    }\n  }\n\n  public remove(node: HTMLElement): void {\n    node.removeAttribute(this.keyName);\n  }\n\n  public value(node: HTMLElement): any {\n    const value = node.getAttribute(this.keyName);\n    if (this.canAdd(node, value) && value) {\n      return value;\n    }\n    return '';\n  }\n}\n","export default class ParchmentError extends Error {\n  public message: string;\n  public name: string;\n  public stack!: string;\n\n  constructor(message: string) {\n    message = '[Parchment] ' + message;\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n}\n","import Attributor from './attributor/attributor.js';\nimport {\n  type Blot,\n  type BlotConstructor,\n  type Root,\n} from './blot/abstract/blot.js';\nimport ParchmentError from './error.js';\nimport Scope from './scope.js';\n\nexport type RegistryDefinition = Attributor | BlotConstructor;\n\nexport interface RegistryInterface {\n  create(scroll: Root, input: Node | string | Scope, value?: any): Blot;\n  query(query: string | Node | Scope, scope: Scope): RegistryDefinition | null;\n  register(...definitions: any[]): any;\n}\n\nexport default class Registry implements RegistryInterface {\n  public static blots = new WeakMap<Node, Blot>();\n\n  public static find(node?: Node | null, bubble = false): Blot | null {\n    if (node == null) {\n      return null;\n    }\n    if (this.blots.has(node)) {\n      return this.blots.get(node) || null;\n    }\n    if (bubble) {\n      let parentNode: Node | null = null;\n      try {\n        parentNode = node.parentNode;\n      } catch (err) {\n        // Probably hit a permission denied error.\n        // A known case is in Firefox, event targets can be anonymous DIVs\n        // inside an input element.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n\n  private attributes: { [key: string]: Attributor } = {};\n  private classes: { [key: string]: BlotConstructor } = {};\n  private tags: { [key: string]: BlotConstructor } = {};\n  private types: { [key: string]: RegistryDefinition } = {};\n\n  public create(scroll: Root, input: Node | string | Scope, value?: any): Blot {\n    const match = this.query(input);\n    if (match == null) {\n      throw new ParchmentError(`Unable to create ${input} blot`);\n    }\n    const blotClass = match as BlotConstructor;\n    const node =\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE\n        ? input\n        : blotClass.create(value);\n\n    const blot = new blotClass(scroll, node as Node, value);\n    Registry.blots.set(blot.domNode, blot);\n    return blot;\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    return Registry.find(node, bubble);\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    let match;\n    if (typeof query === 'string') {\n      match = this.types[query] || this.attributes[query];\n      // @ts-expect-error Fix me later\n    } else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n      match = this.types.text;\n    } else if (typeof query === 'number') {\n      if (query & Scope.LEVEL & Scope.BLOCK) {\n        match = this.types.block;\n      } else if (query & Scope.LEVEL & Scope.INLINE) {\n        match = this.types.inline;\n      }\n    } else if (query instanceof Element) {\n      const names = (query.getAttribute('class') || '').split(/\\s+/);\n      names.some((name) => {\n        match = this.classes[name];\n        if (match) {\n          return true;\n        }\n        return false;\n      });\n      match = match || this.tags[query.tagName];\n    }\n    if (match == null) {\n      return null;\n    }\n    if (\n      'scope' in match &&\n      scope & Scope.LEVEL & match.scope &&\n      scope & Scope.TYPE & match.scope\n    ) {\n      return match;\n    }\n    return null;\n  }\n\n  public register(...definitions: RegistryDefinition[]): RegistryDefinition[] {\n    return definitions.map((definition) => {\n      const isBlot = 'blotName' in definition;\n      const isAttr = 'attrName' in definition;\n      if (!isBlot && !isAttr) {\n        throw new ParchmentError('Invalid definition');\n      } else if (isBlot && definition.blotName === 'abstract') {\n        throw new ParchmentError('Cannot register abstract class');\n      }\n      const key = isBlot\n        ? definition.blotName\n        : isAttr\n          ? definition.attrName\n          : (undefined as never); // already handled by above checks\n      this.types[key] = definition;\n\n      if (isAttr) {\n        if (typeof definition.keyName === 'string') {\n          this.attributes[definition.keyName] = definition;\n        }\n      } else if (isBlot) {\n        if (definition.className) {\n          this.classes[definition.className] = definition;\n        }\n        if (definition.tagName) {\n          if (Array.isArray(definition.tagName)) {\n            definition.tagName = definition.tagName.map((tagName: string) => {\n              return tagName.toUpperCase();\n            });\n          } else {\n            definition.tagName = definition.tagName.toUpperCase();\n          }\n          const tagNames = Array.isArray(definition.tagName)\n            ? definition.tagName\n            : [definition.tagName];\n          tagNames.forEach((tag: string) => {\n            if (this.tags[tag] == null || definition.className == null) {\n              this.tags[tag] = definition;\n            }\n          });\n        }\n      }\n      return definition;\n    });\n  }\n}\n","import Attributor from './attributor.js';\n\nfunction match(node: HTMLElement, prefix: string): string[] {\n  const className = node.getAttribute('class') || '';\n  return className\n    .split(/\\s+/)\n    .filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\n\nclass ClassAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('class') || '')\n      .split(/\\s+/)\n      .map((name) => name.split('-').slice(0, -1).join('-'));\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    this.remove(node);\n    node.classList.add(`${this.keyName}-${value}`);\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    const matches = match(node, this.keyName);\n    matches.forEach((name) => {\n      node.classList.remove(name);\n    });\n    if (node.classList.length === 0) {\n      node.removeAttribute('class');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    const result = match(node, this.keyName)[0] || '';\n    const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default ClassAttributor;\n","import Attributor from './attributor.js';\n\nfunction camelize(name: string): string {\n  const parts = name.split('-');\n  const rest = parts\n    .slice(1)\n    .map((part: string) => part[0].toUpperCase() + part.slice(1))\n    .join('');\n  return parts[0] + rest;\n}\n\nclass StyleAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('style') || '').split(';').map((value) => {\n      const arr = value.split(':');\n      return arr[0].trim();\n    });\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = value;\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = '';\n    if (!node.getAttribute('style')) {\n      node.removeAttribute('style');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    // @ts-expect-error Fix me later\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default StyleAttributor;\n","import type { Formattable } from '../blot/abstract/blot.js';\nimport Registry from '../registry.js';\nimport Scope from '../scope.js';\nimport Attributor from './attributor.js';\nimport ClassAttributor from './class.js';\nimport StyleAttributor from './style.js';\n\nclass AttributorStore {\n  private attributes: { [key: string]: Attributor } = {};\n  private domNode: HTMLElement;\n\n  constructor(domNode: HTMLElement) {\n    this.domNode = domNode;\n    this.build();\n  }\n\n  public attribute(attribute: Attributor, value: any): void {\n    // verb\n    if (value) {\n      if (attribute.add(this.domNode, value)) {\n        if (attribute.value(this.domNode) != null) {\n          this.attributes[attribute.attrName] = attribute;\n        } else {\n          delete this.attributes[attribute.attrName];\n        }\n      }\n    } else {\n      attribute.remove(this.domNode);\n      delete this.attributes[attribute.attrName];\n    }\n  }\n\n  public build(): void {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) {\n      return;\n    }\n    const attributes = Attributor.keys(this.domNode);\n    const classes = ClassAttributor.keys(this.domNode);\n    const styles = StyleAttributor.keys(this.domNode);\n    attributes\n      .concat(classes)\n      .concat(styles)\n      .forEach((name) => {\n        const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n        if (attr instanceof Attributor) {\n          this.attributes[attr.attrName] = attr;\n        }\n      });\n  }\n\n  public copy(target: Formattable): void {\n    Object.keys(this.attributes).forEach((key) => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n\n  public move(target: Formattable): void {\n    this.copy(target);\n    Object.keys(this.attributes).forEach((key) => {\n      this.attributes[key].remove(this.domNode);\n    });\n    this.attributes = {};\n  }\n\n  public values(): { [key: string]: any } {\n    return Object.keys(this.attributes).reduce(\n      (attributes: { [key: string]: any }, name: string) => {\n        attributes[name] = this.attributes[name].value(this.domNode);\n        return attributes;\n      },\n      {},\n    );\n  }\n}\n\nexport default AttributorStore;\n","import ParchmentError from '../../error.js';\nimport Registry from '../../registry.js';\nimport Scope from '../../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './blot.js';\n\nclass ShadowBlot implements Blot {\n  public static blotName = 'abstract';\n  public static className: string;\n  public static requiredContainer: BlotConstructor;\n  public static scope: Scope;\n  public static tagName: string | string[];\n\n  public static create(rawValue?: unknown): Node {\n    if (this.tagName == null) {\n      throw new ParchmentError('Blot definition missing tagName');\n    }\n    let node: HTMLElement;\n    let value: string | number | undefined;\n    if (Array.isArray(this.tagName)) {\n      if (typeof rawValue === 'string') {\n        value = rawValue.toUpperCase();\n        if (parseInt(value, 10).toString() === value) {\n          value = parseInt(value, 10);\n        }\n      } else if (typeof rawValue === 'number') {\n        value = rawValue;\n      }\n      if (typeof value === 'number') {\n        node = document.createElement(this.tagName[value - 1]);\n      } else if (value && this.tagName.indexOf(value) > -1) {\n        node = document.createElement(value);\n      } else {\n        node = document.createElement(this.tagName[0]);\n      }\n    } else {\n      node = document.createElement(this.tagName);\n    }\n    if (this.className) {\n      node.classList.add(this.className);\n    }\n    return node;\n  }\n\n  public prev: Blot | null;\n  public next: Blot | null;\n  // @ts-expect-error Fix me later\n  public parent: Parent;\n\n  // Hack for accessing inherited static methods\n  get statics(): any {\n    return this.constructor;\n  }\n  constructor(\n    public scroll: Root,\n    public domNode: Node,\n  ) {\n    Registry.blots.set(domNode, this);\n    this.prev = null;\n    this.next = null;\n  }\n\n  public attach(): void {\n    // Nothing to do\n  }\n\n  public clone(): Blot {\n    const domNode = this.domNode.cloneNode(false);\n    return this.scroll.create(domNode);\n  }\n\n  public detach(): void {\n    if (this.parent != null) {\n      this.parent.removeChild(this);\n    }\n    Registry.blots.delete(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    const blot = this.isolate(index, length);\n    blot.remove();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    const blot = this.isolate(index, length);\n    if (this.scroll.query(name, Scope.BLOT) != null && value) {\n      blot.wrap(name, value);\n    } else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n      const parent = this.scroll.create(this.statics.scope) as Parent &\n        Formattable;\n      blot.wrap(parent);\n      parent.format(name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const blot =\n      def == null\n        ? this.scroll.create('text', value)\n        : this.scroll.create(value, def);\n    const ref = this.split(index);\n    this.parent.insertBefore(blot, ref || undefined);\n  }\n\n  public isolate(index: number, length: number): Blot {\n    const target = this.split(index);\n    if (target == null) {\n      throw new Error('Attempt to isolate at end');\n    }\n    target.split(length);\n    return target;\n  }\n\n  public length(): number {\n    return 1;\n  }\n\n  public offset(root: Blot = this.parent): number {\n    if (this.parent == null || this === root) {\n      return 0;\n    }\n    return this.parent.children.offset(this) + this.parent.offset(root);\n  }\n\n  public optimize(_context?: { [key: string]: any }): void {\n    if (\n      this.statics.requiredContainer &&\n      !(this.parent instanceof this.statics.requiredContainer)\n    ) {\n      this.wrap(this.statics.requiredContainer.blotName);\n    }\n  }\n\n  public remove(): void {\n    if (this.domNode.parentNode != null) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n    this.detach();\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(replacement, this.next || undefined);\n      this.remove();\n    }\n    return replacement;\n  }\n\n  public split(index: number, _force?: boolean): Blot | null {\n    return index === 0 ? this : this.next;\n  }\n\n  public update(\n    _mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    // Nothing to do by default\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper =\n      typeof name === 'string'\n        ? (this.scroll.create(name, value) as Parent)\n        : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(wrapper, this.next || undefined);\n    }\n    if (typeof wrapper.appendChild !== 'function') {\n      throw new ParchmentError(`Cannot wrap ${name}`);\n    }\n    wrapper.appendChild(this);\n    return wrapper;\n  }\n}\n\nexport default ShadowBlot;\n","import Scope from '../../scope.js';\nimport type { Leaf } from './blot.js';\nimport ShadowBlot from './shadow.js';\n\nclass LeafBlot extends ShadowBlot implements Leaf {\n  public static scope = Scope.INLINE_BLOT;\n\n  /**\n   * Returns the value represented by domNode if it is this Blot's type\n   * No checking that domNode can represent this Blot type is required so\n   * applications needing it should check externally before calling.\n   */\n  public static value(_domNode: Node): any {\n    return true;\n  }\n\n  /**\n   * Given location represented by node and offset from DOM Selection Range,\n   * return index to that location.\n   */\n  public index(node: Node, offset: number): number {\n    if (\n      this.domNode === node ||\n      this.domNode.compareDocumentPosition(node) &\n        Node.DOCUMENT_POSITION_CONTAINED_BY\n    ) {\n      return Math.min(offset, 1);\n    }\n    return -1;\n  }\n\n  /**\n   * Given index to location within blot, return node and offset representing\n   * that location, consumable by DOM Selection Range\n   */\n  public position(index: number, _inclusive?: boolean): [Node, number] {\n    const childNodes: Node[] = Array.from(this.parent.domNode.childNodes);\n    let offset = childNodes.indexOf(this.domNode);\n    if (index > 0) {\n      offset += 1;\n    }\n    return [this.parent.domNode, offset];\n  }\n\n  /**\n   * Return value represented by this blot\n   * Should not change without interaction from API or\n   * user change detectable by update()\n   */\n  public value(): any {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || true,\n    };\n  }\n}\n\nexport default LeafBlot;\n","import type LinkedNode from './linked-node.js';\n\nclass LinkedList<T extends LinkedNode> {\n  public head: T | null;\n  public tail: T | null;\n  public length: number;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  public append(...nodes: T[]): void {\n    this.insertBefore(nodes[0], null);\n    if (nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n\n  public at(index: number): T | null {\n    const next = this.iterator();\n    let cur = next();\n    while (cur && index > 0) {\n      index -= 1;\n      cur = next();\n    }\n    return cur;\n  }\n\n  public contains(node: T): boolean {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      if (cur === node) {\n        return true;\n      }\n      cur = next();\n    }\n    return false;\n  }\n\n  public indexOf(node: T): number {\n    const next = this.iterator();\n    let cur = next();\n    let index = 0;\n    while (cur) {\n      if (cur === node) {\n        return index;\n      }\n      index += 1;\n      cur = next();\n    }\n    return -1;\n  }\n\n  public insertBefore(node: T | null, refNode: T | null): void {\n    if (node == null) {\n      return;\n    }\n    this.remove(node);\n    node.next = refNode;\n    if (refNode != null) {\n      node.prev = refNode.prev;\n      if (refNode.prev != null) {\n        refNode.prev.next = node;\n      }\n      refNode.prev = node;\n      if (refNode === this.head) {\n        this.head = node;\n      }\n    } else if (this.tail != null) {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    } else {\n      node.prev = null;\n      this.head = this.tail = node;\n    }\n    this.length += 1;\n  }\n\n  public offset(target: T): number {\n    let index = 0;\n    let cur = this.head;\n    while (cur != null) {\n      if (cur === target) {\n        return index;\n      }\n      index += cur.length();\n      cur = cur.next as T;\n    }\n    return -1;\n  }\n\n  public remove(node: T): void {\n    if (!this.contains(node)) {\n      return;\n    }\n    if (node.prev != null) {\n      node.prev.next = node.next;\n    }\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n    if (node === this.head) {\n      this.head = node.next as T;\n    }\n    if (node === this.tail) {\n      this.tail = node.prev as T;\n    }\n    this.length -= 1;\n  }\n\n  public iterator(curNode: T | null = this.head): () => T | null {\n    // TODO use yield when we can\n    return (): T | null => {\n      const ret = curNode;\n      if (curNode != null) {\n        curNode = curNode.next as T;\n      }\n      return ret;\n    };\n  }\n\n  public find(index: number, inclusive = false): [T | null, number] {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      const length = cur.length();\n      if (\n        index < length ||\n        (inclusive &&\n          index === length &&\n          (cur.next == null || cur.next.length() !== 0))\n      ) {\n        return [cur, index];\n      }\n      index -= length;\n      cur = next();\n    }\n    return [null, 0];\n  }\n\n  public forEach(callback: (cur: T) => void): void {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      callback(cur);\n      cur = next();\n    }\n  }\n\n  public forEachAt(\n    index: number,\n    length: number,\n    callback: (cur: T, offset: number, length: number) => void,\n  ): void {\n    if (length <= 0) {\n      return;\n    }\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    while (cur && curIndex < index + length) {\n      const curLength = cur.length();\n      if (index > curIndex) {\n        callback(\n          cur,\n          index - curIndex,\n          Math.min(length, curIndex + curLength - index),\n        );\n      } else {\n        callback(cur, 0, Math.min(curLength, index + length - curIndex));\n      }\n      curIndex += curLength;\n      cur = next();\n    }\n  }\n\n  public map(callback: (cur: T) => any): any[] {\n    return this.reduce((memo: T[], cur: T) => {\n      memo.push(callback(cur));\n      return memo;\n    }, []);\n  }\n\n  public reduce<M>(callback: (memo: M, cur: T) => M, memo: M): M {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      memo = callback(memo, cur);\n      cur = next();\n    }\n    return memo;\n  }\n}\n\nexport default LinkedList;\n","import LinkedList from '../../collection/linked-list.js';\nimport ParchmentError from '../../error.js';\nimport Scope from '../../scope.js';\nimport type { Blot, BlotConstructor, Parent, Root } from './blot.js';\nimport ShadowBlot from './shadow.js';\n\nfunction makeAttachedBlot(node: Node, scroll: Root): Blot {\n  const found = scroll.find(node);\n  if (found) return found;\n  try {\n    return scroll.create(node);\n  } catch (e) {\n    const blot = scroll.create(Scope.INLINE);\n    Array.from(node.childNodes).forEach((child: Node) => {\n      blot.domNode.appendChild(child);\n    });\n    if (node.parentNode) {\n      node.parentNode.replaceChild(blot.domNode, node);\n    }\n    blot.attach();\n    return blot;\n  }\n}\n\nclass ParentBlot extends ShadowBlot implements Parent {\n  /**\n   * Whitelist array of Blots that can be direct children.\n   */\n  public static allowedChildren?: BlotConstructor[];\n\n  /**\n   * Default child blot to be inserted if this blot becomes empty.\n   */\n  public static defaultChild?: BlotConstructor;\n  public static uiClass = '';\n\n  public children!: LinkedList<Blot>;\n  public domNode!: HTMLElement;\n  public uiNode: HTMLElement | null = null;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.build();\n  }\n\n  public appendChild(other: Blot): void {\n    this.insertBefore(other);\n  }\n\n  public attach(): void {\n    super.attach();\n    this.children.forEach((child) => {\n      child.attach();\n    });\n  }\n\n  public attachUI(node: HTMLElement): void {\n    if (this.uiNode != null) {\n      this.uiNode.remove();\n    }\n    this.uiNode = node;\n    if (ParentBlot.uiClass) {\n      this.uiNode.classList.add(ParentBlot.uiClass);\n    }\n    this.uiNode.setAttribute('contenteditable', 'false');\n    this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n\n  /**\n   * Called during construction, should fill its own children LinkedList.\n   */\n  public build(): void {\n    this.children = new LinkedList<Blot>();\n    // Need to be reversed for if DOM nodes already in order\n    Array.from(this.domNode.childNodes)\n      .filter((node: Node) => node !== this.uiNode)\n      .reverse()\n      .forEach((node: Node) => {\n        try {\n          const child = makeAttachedBlot(node, this.scroll);\n          this.insertBefore(child, this.children.head || undefined);\n        } catch (err) {\n          if (err instanceof ParchmentError) {\n            return;\n          } else {\n            throw err;\n          }\n        }\n      });\n  }\n\n  public deleteAt(index: number, length: number): void {\n    if (index === 0 && length === this.length()) {\n      return this.remove();\n    }\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n\n  public descendant<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index: number,\n  ): [T | null, number];\n  public descendant(\n    criteria: (blot: Blot) => boolean,\n    index: number,\n  ): [Blot | null, number];\n  public descendant(criteria: any, index = 0): [Blot | null, number] {\n    const [child, offset] = this.children.find(index);\n    if (\n      (criteria.blotName == null && criteria(child)) ||\n      (criteria.blotName != null && child instanceof criteria)\n    ) {\n      return [child as any, offset];\n    } else if (child instanceof ParentBlot) {\n      return child.descendant(criteria, offset);\n    } else {\n      return [null, -1];\n    }\n  }\n\n  public descendants<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index?: number,\n    length?: number,\n  ): T[];\n  public descendants(\n    criteria: (blot: Blot) => boolean,\n    index?: number,\n    length?: number,\n  ): Blot[];\n  public descendants(\n    criteria: any,\n    index = 0,\n    length: number = Number.MAX_VALUE,\n  ): Blot[] {\n    let descendants: Blot[] = [];\n    let lengthLeft = length;\n    this.children.forEachAt(\n      index,\n      length,\n      (child: Blot, childIndex: number, childLength: number) => {\n        if (\n          (criteria.blotName == null && criteria(child)) ||\n          (criteria.blotName != null && child instanceof criteria)\n        ) {\n          descendants.push(child);\n        }\n        if (child instanceof ParentBlot) {\n          descendants = descendants.concat(\n            child.descendants(criteria, childIndex, lengthLeft),\n          );\n        }\n        lengthLeft -= childLength;\n      },\n    );\n    return descendants;\n  }\n\n  public detach(): void {\n    this.children.forEach((child) => {\n      child.detach();\n    });\n    super.detach();\n  }\n\n  public enforceAllowedChildren(): void {\n    let done = false;\n    this.children.forEach((child: Blot) => {\n      if (done) {\n        return;\n      }\n      const allowed = this.statics.allowedChildren.some(\n        (def: BlotConstructor) => child instanceof def,\n      );\n      if (allowed) {\n        return;\n      }\n      if (child.statics.scope === Scope.BLOCK_BLOT) {\n        if (child.next != null) {\n          this.splitAfter(child);\n        }\n        if (child.prev != null) {\n          this.splitAfter(child.prev);\n        }\n        child.parent.unwrap();\n        done = true;\n      } else if (child instanceof ParentBlot) {\n        child.unwrap();\n      } else {\n        child.remove();\n      }\n    });\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const [child, offset] = this.children.find(index);\n    if (child) {\n      child.insertAt(offset, value, def);\n    } else {\n      const blot =\n        def == null\n          ? this.scroll.create('text', value)\n          : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n\n  public insertBefore(childBlot: Blot, refBlot?: Blot | null): void {\n    if (childBlot.parent != null) {\n      childBlot.parent.children.remove(childBlot);\n    }\n    let refDomNode: Node | null = null;\n    this.children.insertBefore(childBlot, refBlot || null);\n    childBlot.parent = this;\n    if (refBlot != null) {\n      refDomNode = refBlot.domNode;\n    }\n    if (\n      this.domNode.parentNode !== childBlot.domNode ||\n      this.domNode.nextSibling !== refDomNode\n    ) {\n      this.domNode.insertBefore(childBlot.domNode, refDomNode);\n    }\n    childBlot.attach();\n  }\n\n  public length(): number {\n    return this.children.reduce((memo, child) => {\n      return memo + child.length();\n    }, 0);\n  }\n\n  public moveChildren(targetParent: Parent, refNode?: Blot | null): void {\n    this.children.forEach((child) => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n\n  public optimize(context?: { [key: string]: any }): void {\n    super.optimize(context);\n    this.enforceAllowedChildren();\n    if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n      this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    if (this.children.length === 0) {\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n        // TODO double check if necessary\n        // child.optimize(context);\n      } else {\n        this.remove();\n      }\n    }\n  }\n\n  public path(index: number, inclusive = false): [Blot, number][] {\n    const [child, offset] = this.children.find(index, inclusive);\n    const position: [Blot, number][] = [[this, index]];\n    if (child instanceof ParentBlot) {\n      return position.concat(child.path(offset, inclusive));\n    } else if (child != null) {\n      position.push([child, offset]);\n    }\n    return position;\n  }\n\n  public removeChild(child: Blot): void {\n    this.children.remove(child);\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (replacement instanceof ParentBlot) {\n      this.moveChildren(replacement);\n    }\n    return super.replaceWith(replacement);\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.clone() as ParentBlot;\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      if (split != null) {\n        after.appendChild(split);\n      }\n    });\n    return after;\n  }\n\n  public splitAfter(child: Blot): Parent {\n    const after = this.clone() as ParentBlot;\n    while (child.next != null) {\n      after.appendChild(child.next);\n    }\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    return after;\n  }\n\n  public unwrap(): void {\n    if (this.parent) {\n      this.moveChildren(this.parent, this.next || undefined);\n    }\n    this.remove();\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    const addedNodes: Node[] = [];\n    const removedNodes: Node[] = [];\n    mutations.forEach((mutation) => {\n      if (mutation.target === this.domNode && mutation.type === 'childList') {\n        addedNodes.push(...mutation.addedNodes);\n        removedNodes.push(...mutation.removedNodes);\n      }\n    });\n    removedNodes.forEach((node: Node) => {\n      // Check node has actually been removed\n      // One exception is Chrome does not immediately remove IFRAMEs\n      // from DOM but MutationRecord is correct in its reported removal\n      if (\n        node.parentNode != null &&\n        // @ts-expect-error Fix me later\n        node.tagName !== 'IFRAME' &&\n        document.body.compareDocumentPosition(node) &\n          Node.DOCUMENT_POSITION_CONTAINED_BY\n      ) {\n        return;\n      }\n      const blot = this.scroll.find(node);\n      if (blot == null) {\n        return;\n      }\n      if (\n        blot.domNode.parentNode == null ||\n        blot.domNode.parentNode === this.domNode\n      ) {\n        blot.detach();\n      }\n    });\n    addedNodes\n      .filter((node) => {\n        return node.parentNode === this.domNode && node !== this.uiNode;\n      })\n      .sort((a, b) => {\n        if (a === b) {\n          return 0;\n        }\n        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n          return 1;\n        }\n        return -1;\n      })\n      .forEach((node) => {\n        let refBlot: Blot | null = null;\n        if (node.nextSibling != null) {\n          refBlot = this.scroll.find(node.nextSibling);\n        }\n        const blot = makeAttachedBlot(node, this.scroll);\n        if (blot.next !== refBlot || blot.next == null) {\n          if (blot.parent != null) {\n            blot.parent.removeChild(this);\n          }\n          this.insertBefore(blot, refBlot || undefined);\n        }\n      });\n    this.enforceAllowedChildren();\n  }\n}\n\nexport default ParentBlot;\n","import Attributor from '../attributor/attributor.js';\nimport AttributorStore from '../attributor/store.js';\nimport Scope from '../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\nimport ParentBlot from './abstract/parent.js';\n\n// Shallow object comparison\nfunction isEqual(\n  obj1: Record<string, unknown>,\n  obj2: Record<string, unknown>,\n): boolean {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n    return false;\n  }\n  for (const prop in obj1) {\n    if (obj1[prop] !== obj2[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass InlineBlot extends ParentBlot implements Formattable {\n  public static allowedChildren: BlotConstructor[] = [InlineBlot, LeafBlot];\n  public static blotName = 'inline';\n  public static scope = Scope.INLINE_BLOT;\n  public static tagName: string | string[] = 'SPAN';\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(InlineBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n    return undefined;\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    if (name === this.statics.blotName && !value) {\n      this.children.forEach((child) => {\n        if (!(child instanceof InlineBlot)) {\n          child = child.wrap(InlineBlot.blotName, true);\n        }\n        this.attributes.copy(child as InlineBlot);\n      });\n      this.unwrap();\n    } else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) {\n        return;\n      }\n      if (format instanceof Attributor) {\n        this.attributes.attribute(format, value);\n      } else if (\n        value &&\n        (name !== this.statics.blotName || this.formats()[name] !== value)\n      ) {\n        this.replaceWith(name, value);\n      }\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (\n      this.formats()[name] != null ||\n      this.scroll.query(name, Scope.ATTRIBUTE)\n    ) {\n      const blot = this.isolate(index, length) as InlineBlot;\n      blot.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) {\n      return this.unwrap(); // unformatted span\n    }\n    const next = this.next;\n    if (\n      next instanceof InlineBlot &&\n      next.prev === this &&\n      isEqual(formats, next.formats())\n    ) {\n      next.moveChildren(this);\n      next.remove();\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as InlineBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper = super.wrap(name, value);\n    if (wrapper instanceof InlineBlot) {\n      this.attributes.move(wrapper);\n    }\n    return wrapper;\n  }\n}\n\nexport default InlineBlot;\n","import Attributor from '../attributor/attributor.js';\nimport AttributorStore from '../attributor/store.js';\nimport Scope from '../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Root,\n} from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\nimport ParentBlot from './abstract/parent.js';\nimport InlineBlot from './inline.js';\n\nclass BlockBlot extends ParentBlot implements Formattable {\n  public static blotName = 'block';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[] = 'P';\n  public static allowedChildren: BlotConstructor[] = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n  ];\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(BlockBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    const format = this.scroll.query(name, Scope.BLOCK);\n    if (format == null) {\n      return;\n    } else if (format instanceof Attributor) {\n      this.attributes.attribute(format, value);\n    } else if (name === this.statics.blotName && !value) {\n      this.replaceWith(BlockBlot.blotName);\n    } else if (\n      value &&\n      (name !== this.statics.blotName || this.formats()[name] !== value)\n    ) {\n      this.replaceWith(name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (this.scroll.query(name, Scope.BLOCK) != null) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n      // Insert text or inline\n      super.insertAt(index, value, def);\n    } else {\n      const after = this.split(index);\n      if (after != null) {\n        const blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else {\n        throw new Error('Attempt to insertAt after block boundaries');\n      }\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as BlockBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n}\n\nexport default BlockBlot;\n","import Scope from '../../scope.js';\nimport BlockBlot from '../block.js';\nimport ParentBlot from './parent.js';\n\nclass ContainerBlot extends ParentBlot {\n  public static blotName = 'container';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[];\n\n  public prev!: BlockBlot | ContainerBlot | null;\n  public next!: BlockBlot | ContainerBlot | null;\n\n  public checkMerge(): boolean {\n    return (\n      this.next !== null && this.next.statics.blotName === this.statics.blotName\n    );\n  }\n\n  public deleteAt(index: number, length: number): void {\n    super.deleteAt(index, length);\n    this.enforceAllowedChildren();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    super.formatAt(index, length, name, value);\n    this.enforceAllowedChildren();\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    super.insertAt(index, value, def);\n    this.enforceAllowedChildren();\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  }\n}\n\nexport default ContainerBlot;\n","import type { Formattable, Root } from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\n\nclass EmbedBlot extends LeafBlot implements Formattable {\n  public static formats(_domNode: HTMLElement, _scroll: Root): any {\n    return undefined;\n  }\n\n  public format(name: string, value: any): void {\n    // super.formatAt wraps, which is what we want in general,\n    // but this allows subclasses to overwrite for formats\n    // that just apply to particular embeds\n    super.formatAt(0, this.length(), name, value);\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (index === 0 && length === this.length()) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\n\nexport default EmbedBlot;\n","import Registry, { type RegistryDefinition } from '../registry.js';\nimport Scope from '../scope.js';\nimport type { Blot, BlotConstructor, Root } from './abstract/blot.js';\nimport ContainerBlot from './abstract/container.js';\nimport ParentBlot from './abstract/parent.js';\nimport BlockBlot from './block.js';\n\nconst OBSERVER_CONFIG = {\n  attributes: true,\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true,\n};\n\nconst MAX_OPTIMIZE_ITERATIONS = 100;\n\nclass ScrollBlot extends ParentBlot implements Root {\n  public static blotName = 'scroll';\n  public static defaultChild = BlockBlot;\n  public static allowedChildren: BlotConstructor[] = [BlockBlot, ContainerBlot];\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName = 'DIV';\n\n  public observer: MutationObserver;\n\n  constructor(\n    public registry: Registry,\n    node: HTMLDivElement,\n  ) {\n    // @ts-expect-error scroll is the root with no parent\n    super(null, node);\n    this.scroll = this;\n    this.build();\n    this.observer = new MutationObserver((mutations: MutationRecord[]) => {\n      this.update(mutations);\n    });\n    this.observer.observe(this.domNode, OBSERVER_CONFIG);\n    this.attach();\n  }\n\n  public create(input: Node | string | Scope, value?: any): Blot {\n    return this.registry.create(this, input, value);\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    const blot = this.registry.find(node, bubble);\n    if (!blot) {\n      return null;\n    }\n    if (blot.scroll === this) {\n      return blot;\n    }\n    return bubble ? this.find(blot.scroll.domNode.parentNode, true) : null;\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    return this.registry.query(query, scope);\n  }\n\n  public register(...definitions: RegistryDefinition[]) {\n    return this.registry.register(...definitions);\n  }\n\n  public build(): void {\n    if (this.scroll == null) {\n      return;\n    }\n    super.build();\n  }\n\n  public detach(): void {\n    super.detach();\n    this.observer.disconnect();\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.update();\n    if (index === 0 && length === this.length()) {\n      this.children.forEach((child) => {\n        child.remove();\n      });\n    } else {\n      super.deleteAt(index, length);\n    }\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.update();\n    super.formatAt(index, length, name, value);\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    this.update();\n    super.insertAt(index, value, def);\n  }\n\n  public optimize(context?: { [key: string]: any }): void;\n  public optimize(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void;\n  public optimize(mutations: any = [], context: any = {}): void {\n    super.optimize(context);\n    const mutationsMap = context.mutationsMap || new WeakMap();\n    // We must modify mutations directly, cannot make copy and then modify\n    let records = Array.from(this.observer.takeRecords());\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    const mark = (blot: Blot | null, markParent = true): void => {\n      if (blot == null || blot === this) {\n        return;\n      }\n      if (blot.domNode.parentNode == null) {\n        return;\n      }\n      if (!mutationsMap.has(blot.domNode)) {\n        mutationsMap.set(blot.domNode, []);\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    const optimize = (blot: Blot): void => {\n      // Post-order traversal\n      if (!mutationsMap.has(blot.domNode)) {\n        return;\n      }\n      if (blot instanceof ParentBlot) {\n        blot.children.forEach(optimize);\n      }\n      mutationsMap.delete(blot.domNode);\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS) {\n        throw new Error('[Parchment] Maximum optimize iterations reached');\n      }\n      remaining.forEach((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === 'childList') {\n            mark(this.find(mutation.previousSibling, false));\n            Array.from(mutation.addedNodes).forEach((node: Node) => {\n              const child = this.find(node, false);\n              mark(child, false);\n              if (child instanceof ParentBlot) {\n                child.children.forEach((grandChild: Blot) => {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === 'attributes') {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = Array.from(this.observer.takeRecords());\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n\n  public update(\n    mutations?: MutationRecord[],\n    context: { [key: string]: any } = {},\n  ): void {\n    mutations = mutations || this.observer.takeRecords();\n    const mutationsMap = new WeakMap();\n    mutations\n      .map((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return null;\n        }\n        if (mutationsMap.has(blot.domNode)) {\n          mutationsMap.get(blot.domNode).push(mutation);\n          return null;\n        } else {\n          mutationsMap.set(blot.domNode, [mutation]);\n          return blot;\n        }\n      })\n      .forEach((blot: Blot | null) => {\n        if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n          blot.update(mutationsMap.get(blot.domNode) || [], context);\n        }\n      });\n    context.mutationsMap = mutationsMap;\n    if (mutationsMap.has(this.domNode)) {\n      super.update(mutationsMap.get(this.domNode), context);\n    }\n    this.optimize(mutations, context);\n  }\n}\n\nexport default ScrollBlot;\n","import Scope from '../scope.js';\nimport type { Blot, Leaf, Root } from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\n\nclass TextBlot extends LeafBlot implements Leaf {\n  public static readonly blotName = 'text';\n  public static scope = Scope.INLINE_BLOT;\n\n  public static create(value: string): Text {\n    return document.createTextNode(value);\n  }\n\n  public static value(domNode: Text): string {\n    return domNode.data;\n  }\n\n  public domNode!: Text;\n  protected text: string;\n\n  constructor(scroll: Root, node: Node) {\n    super(scroll, node);\n    this.text = this.statics.value(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.domNode.data = this.text =\n      this.text.slice(0, index) + this.text.slice(index + length);\n  }\n\n  public index(node: Node, offset: number): number {\n    if (this.domNode === node) {\n      return offset;\n    }\n    return -1;\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null) {\n      this.text = this.text.slice(0, index) + value + this.text.slice(index);\n      this.domNode.data = this.text;\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n\n  public length(): number {\n    return this.text.length;\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    this.text = this.statics.value(this.domNode);\n    if (this.text.length === 0) {\n      this.remove();\n    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n      this.insertAt(this.length(), (this.next as TextBlot).value());\n      this.next.remove();\n    }\n  }\n\n  public position(index: number, _inclusive = false): [Node, number] {\n    return [this.domNode, index];\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.scroll.create(this.domNode.splitText(index));\n    this.parent.insertBefore(after, this.next || undefined);\n    this.text = this.statics.value(this.domNode);\n    return after;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    if (\n      mutations.some((mutation) => {\n        return (\n          mutation.type === 'characterData' && mutation.target === this.domNode\n        );\n      })\n    ) {\n      this.text = this.statics.value(this.domNode);\n    }\n  }\n\n  public value(): string {\n    return this.text;\n  }\n}\n\nexport default TextBlot;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}